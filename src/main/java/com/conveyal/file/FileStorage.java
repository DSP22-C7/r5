package com.conveyal.file;

import java.io.File;
import java.util.function.BiConsumer;
import java.util.function.Function;

/**
 * Store (and maybe mirror) immutable files.
 * These are always seen as local files on the local filesystem,
 * but may be made more permanent (accessible to workers and future backends).
 * <p>
 * The add/remove/etc. methods are all blocking calls now for simplicity, i.e. if you add a file, all other components
 * of the system are known to be able to see it as soon as the method returns.
 * <p>
 * This does not handle storing file metadata in MongoDB. That is a separate concern.
 * Workers for example need to get files without looking into our database.
 * Our file metadata handling component could wrap this, so all backend file operations implicitly had metadata.
 * <p>
 * In the S3-based implementation we need to set content type and compression details on S3.
 * We plan to do that by inspecting the "magic number" bytes at the beginning of the file and auto-setting the
 * content type.
 */
public abstract class FileStorage {
    /**
     * Takes an already existing file on the local filesystem and registers it as a permanent, immutable file to be
     * made available to all analysis components including workers and future backends.
     * <p>
     * If a file was uploaded in a form, we can call DiskFileItem.getStoreLocation to get the file, which according
     * to that method's Javadoc we are allowed to rename to our own location.
     * <p>
     * If the file was created by the backend, it should be created in a temp file. Once the file is completely
     * constructed / written out, it should be closed and then this method called on it.
     */
    public abstract void moveIntoStorage(FileStorageKey fileStorageKey, File file);

    /**
     * This should be treated as immutable - never write to a file returned from this method.
     * That could be enforced by making our own class with no write methods, that only allows reading the file.
     */
    public abstract File getFile(FileStorageKey fileStorageKey);

    /**
     * Get the URL for the File located at the FileStorageKey. This can be a file:// URL when running locally or a URL
     * available on the web generated by S3.
     */
    public abstract String getURL(FileStorageKey fileStorageKey);

    /**
     * Delete the File located at the FileStorageKey.
     */
    public abstract void delete(FileStorageKey fileStorageKey);

    /**
     * When a new server is spun up there will be no local files. In instances where we derive files from other files
     * (ex: creating Tiffs from Grids) and if they are already created we only need to return a download URL and therefore
     * not need to retrieve the file at all, it would be useful to check if the file exists in the FileStorage without
     * actually retrieving it.
     */
    public abstract boolean exists(FileStorageKey fileStorageKey);

    /**
     * Create a `moveIntoStorage` method with a pre-defined bucket.
     */
    public BiConsumer<String, File> createMoveIntoStorage (String bucket) {
        return (String key, File file) -> this.moveIntoStorage(new FileStorageKey(bucket, key), file);
    }

    /**
     * Create a `getFile` method with a pre-defined bucket.
     */
    public Function<String, File> createGetFile (String bucket) {
        return (String key) -> this.getFile(new FileStorageKey(bucket, key));
    }
}
